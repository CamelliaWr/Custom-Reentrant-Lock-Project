/**
 * 等待策略接口，定义了锁竞争时的线程等待行为。
 *
 * 该接口抽象了不同等待策略的实现，允许锁实现灵活配置
 * 线程在竞争锁时的等待方式，平衡响应性、CPU使用率和公平性。
 *
 * 设计目标：
 * - 提供统一的等待策略抽象
 * - 支持多种等待机制（自旋、阻塞、混合）
 * - 允许性能调优和策略切换
 * - 支持中断响应，保证系统响应性
 *
 * 策略类型：
 * - 自旋策略：适用于短锁持有时间，避免上下文切换
 * - 阻塞策略：适用于长锁持有时间，节省CPU资源
 * - 混合策略：结合自旋和阻塞，适应不同场景
 * - 自适应策略：根据运行时情况动态调整
 *
 * 使用场景：
 * - CLH锁、MCS锁等自旋锁的等待机制
 * - 自定义锁实现的等待策略
 * - 高性能并发数据结构的同步等待
 * - 需要精细控制等待行为的场景
 *
 * @author 示例作者
 * @since 1.0
 * @see BusySpinStrategy
 * @see SpinThenParkStrategy
 */
package com.example.lock.strategy;

/**
 * 等待策略的抽象接口。
 *
 * 该接口定义了锁竞争时线程等待行为的基本契约，
 * 实现类可以提供不同的等待机制，如：
 * - 纯自旋等待
 * - 自旋后阻塞
 * - 指数退避
 * - 自适应等待
 *
 * 队列实现在自旋或park操作时会调用该接口的方法，
 * 使得等待行为可以统一配置和优化。
 */
public interface WaitStrategy {

    /**
     * 执行等待操作。
     *
     * 实现类定义具体的等待逻辑，可能包括：
     * - 自旋等待：循环检查条件，避免线程阻塞
     * - 线程阻塞：让出CPU时间片，等待被唤醒
     * - 混合策略：先自旋后阻塞，平衡响应性和资源使用
     * - 时间控制：支持超时和精确的等待时间
     *
     * 实现要求：
     * - 必须响应线程中断，抛出InterruptedException
     * - 应该考虑CPU使用率和响应性的平衡
     * - 需要处理伪唤醒和竞态条件
     * - 应该提供合理的默认等待时间
     *
     * 中断处理：
     * - 检测线程中断状态
     * - 清除中断状态
     * - 抛出InterruptedException
     * - 允许调用者决定如何处理中断
     *
     * @throws InterruptedException 如果线程在等待过程中被中断
     *
     * @implSpec 实现必须正确响应中断请求
     * @implNote 实现类应该考虑性能优化和资源使用
     * @implNote 不同的策略适用于不同的锁竞争模式
     *
     * @see Thread#interrupted()
     * @see LockSupport#park()
     * @see Thread#onSpinWait()
     */
    void await() throws InterruptedException;
}